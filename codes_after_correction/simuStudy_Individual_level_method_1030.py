#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul  6 16:04:04 2021

@author: Yunjun Zhang

This file tests the performance of the IIH model with the incidence data generated by the individual level simulation .
The main function is the Incidence_Simu_IND0921 which generates the incidence data with an individual-level methods.

"""
import numpy as np
import pandas as pd
from scipy.stats import nbinom
from scipy.optimize import fsolve
from scipy import special
import scipy.integrate as integrate
from scipy.stats import gamma
import pymc3 as pm
import arviz as az
from scipy import signal


def gamma2discrete(mean_GT,sd_GT,MaxInfctPrd):
    
    '''
    Parameters
    ----------
    mean_GT : float
        The mean of generation time.
    sd_GT : float
        the sd of generation time.
    MaxInfctPrd : TYPE
        DESCRIPTION.

    Returns
    -------
    np.array
        the ratio for each .

    '''
    shape_para = (mean_GT/sd_GT)**2;
    rate_para  = shape_para/mean_GT
    
    wRatio = np.zeros(MaxInfctPrd+1)
    for tmps in range(1,len(wRatio)):
        wRatio[tmps] = gamma.cdf(tmps+0.5,shape_para,scale = 1/rate_para) - gamma.cdf(tmps-0.5,shape_para,scale = 1/rate_para)
    
    return wRatio/np.sum(wRatio);

def ttlInfFun(IncData,Wratios):
    # return the total infectiousness at time t
    # truncate or expand the IncData 
    wm = len(Wratios)
    Im = len(IncData)
    if Im <= wm-1:
        FOI = signal.convolve(IncData,Wratios[1:Im+1], mode='valid')
    elif Im > wm-1:
        FOI = signal.convolve(IncData[Im-wm+1:],Wratios[1:], mode='valid')
    return FOI[0]   


# generate the incidence data in an individual-level way

def Incidence_Simu_IND0921(SimDays,IndexNum,tmpRt,tmpKt,Wratios):  
    '''

    Parameters
    ----------
    SimDays : SimDays = 10; # the time length of simulation in days.
    IndexNum : TYPE the intial number of cases .
    Rngt, dispK : the Ro and k for the gamma distribution,that is, rate~Gamma(shape=k,rate = k/Ro)
    Wratios : the weight distribution defined by the generation time.
    
    Returns
    -------
    the incidence data for 0 to SimDays.

    '''

    # initial the situation 
    # the initial cases on the first day 
    TranEvt = np.zeros((IndexNum,2))
    TranEvt[:,0] = 0 # TranEvt = [Mother_ID, date_of_infection]
    
    rwId = 0;
    totalInfID = TranEvt.shape[0]
    tmpTime = 0
    while rwId<totalInfID:
        tmpTime = TranEvt[rwId,1];
        if tmpTime<SimDays:
            '''
            generate 2nd cases for the particular index case at time tmpTime
            '''
            tmpEvt = IND_2ndCase(Wratios,tmpRt,tmpKt); # generate the new events
            '''
            arrange these 2nd cases to the days in the index's infectious period
            '''
            if tmpEvt.any():
                tmpEvt[:,0] = rwId+1;
                tmpEvt[:,1] = tmpEvt[:,1] + tmpTime;    
                # tmpEvt = tmpEvt[tmpEvt[:,1].argsort()];
                # tmpEvt = tmpEvt[tmpEvt[:,1]<=SimDays,:] # keep the event earlier than the last da
                TranEvt = np.concatenate((TranEvt,tmpEvt))
            
            '''
            update new information
            '''
        totalInfID = TranEvt.shape[0]
        rwId +=1;
    
    # rearrange the tranEvnt and keep the events no later than the SimDays
    TranEvt = TranEvt[TranEvt[:,1].argsort()]; 
    TranEvt = TranEvt[TranEvt[:,1]<SimDays]
    
    # transform the transEvnt to Inc data
    T_step, evtCnt = np.unique(TranEvt[:,1],return_counts=True)
    IncData = np.zeros(SimDays);
    IncData[T_step.astype(int)] = evtCnt;
    
    return IncData;


def IND_2ndCase(Wratios,tmpRt,tmpKt):
    '''
    to generate the 2nd cases of an index
    '''
    sndCase = list(map(lambda x: nbinom.rvs(x*tmpKt,tmpKt/(tmpRt+tmpKt)),Wratios[1:]))
    sndCase_num = np.sum(np.array(sndCase))
    re = np.zeros(1)
    if sndCase_num >0:     # if there is any 2nd case    
        for i in range(len(sndCase)):
            if sndCase[i]>0:
                tmpEvt = np.zeros((sndCase[i],2))
                tmpEvt[:,1] = i+1;
                re = np.concatenate((re,tmpEvt)) if re.any() else tmpEvt;
    return re;

   
def sngleRun0707(mean_GT,sd_GT,MaxInfctPrd,initialCase,tmpRt,tmpKt,tmpDays):    
    # SimDays --the length of simulation
    # initialCase -- the number of cases on time 0;
    # 1) simulation the incidence data
    zero_cnt = 1
    while zero_cnt >0:      
        # generate the incidence data
        simLen = 24
        Wratios = gamma2discrete(mean_GT,sd_GT,MaxInfctPrd)
        EpiSimuData = Incidence_Simu_IND0921(simLen,initialCase,tmpRt,tmpKt,Wratios)
        
        # imput for inference
        tempFOI = signal.convolve(np.concatenate((np.zeros(len(Wratios)-1),EpiSimuData)),Wratios, mode='valid')    
        IncData_impt = EpiSimuData[-tmpDays:]
        FOI_impt     = tempFOI[-tmpDays:]
        zero_cnt = np.where(abs(FOI_impt) < 0.00001)[0].size
    
    # performe inference
    basic_model = pm.Model()
    chain_len = 10000
    brn_st = int(chain_len*0.1)
    with basic_model:
        k_para =  pm.Uniform("k_disp",0,100)
        Rt_para = pm.Uniform("Rt", 0.1, 10);
        nb_r = FOI_impt*k_para;
        nb_p = k_para/(Rt_para+k_para);    
        Y_obs = pm.NegativeBinomial("Y_obs", n=nb_r, p=nb_p, observed=IncData_impt)
        trace = pm.sample(chain_len, return_inferencedata=False,chains=1,cores=1);
    
    map_estimate = pm.find_MAP(model=basic_model)
    k_hpd = az.hdi(trace["k_disp"][brn_st:],hdi_prob = 0.95)
    R_hpd = az.hdi(trace["Rt"][brn_st:],hdi_prob = 0.95) 
    
    kt_ess = az.ess(trace["k_disp"][brn_st:])
    Rt_ess = az.ess(trace["Rt"][brn_st:])   
    # del trace
    # pm.memoize.clear_cache()
    return [map_estimate['Rt'],map_estimate['k_disp'],R_hpd[0],R_hpd[1],k_hpd[0],k_hpd[1],kt_ess,Rt_ess];



def mltRun(mean_GT,sd_GT,MaxInfctPrd,initialCase,tmpRt,tmpKt,tmpDays,simN):
    # simN-- number of simulation
    # 1) perform simulation and inference
    # return [Rt_map,Rt_mean,R_hpd[0],R_hpd[1],kt_map,k_mean,k_median,k_hpd[0],k_hpd[1]];
    bias_R = [];
    bias_k = [];
    cvrg_re = 0;
    cprb_re = 0
    Rt_mean = 0;
    kt_mean = 0;
    kt_ess = 0;
    Rt_ess = 0;
    for i in range(simN):
        tmpInfer = sngleRun0707(mean_GT,sd_GT,MaxInfctPrd,initialCase,tmpRt,tmpKt,tmpDays)
        temp_bias_R,temp_bias_k,temp_cvrg,tmp_cprb = Esti_Evl(tmpInfer,tmpRt,tmpKt);
        bias_R += [temp_bias_R];
        bias_k += [temp_bias_k];
        cvrg_re += temp_cvrg
        cprb_re += tmp_cprb
        kt_ess += tmpInfer[6];
        Rt_ess += tmpInfer[7];
    MAD_R = np.median(np.abs(np.array(bias_R)));
    MAD_k = np.median(np.abs(np.array(bias_k)));
    MBS_R = np.median(np.array(bias_R));
    MBS_k = np.median(np.array(bias_k)); 
    cvrg_re = cvrg_re/simN
    cprb_re = cprb_re/simN
    kt_ess = kt_ess/simN
    Rt_ess = Rt_ess/simN
    # del ase_R;
    # del ase_k;
    return [MAD_R,MAD_k,cvrg_re[0],cvrg_re[1],cprb_re[0],cprb_re[1],kt_ess,Rt_ess,MBS_R,MBS_k]


def Esti_Evl(tmpInfer,tmpRt,tmpKt):
    # tvInference starts from time = 1
    # calculate the coverage and RMSE based on the MAP and the related HPD 
    evl_cvrg = np.zeros(2)# R_hpd_cvrg,k_hpd_cvrg
    evl_cprb = np.zeros(2)# R_hpd_cvrg,k_hpd_cvrg
    
    evl_bias_R = (tmpInfer[0] - tmpRt);
    evl_bias_k = (tmpInfer[1] - tmpKt);
    evl_cprb[0] = (tmpInfer[2]<=tmpRt)*(tmpInfer[3]>=tmpRt)
    evl_cprb[1] = (tmpInfer[1]<1)*(tmpKt<1) + (tmpInfer[1]>1)*(tmpKt>1) # kt and K at the same side of 1
    
    evl_cvrg[0] = (tmpInfer[2]<=tmpRt)*(tmpInfer[3]>=tmpRt)
    evl_cvrg[1] = (tmpInfer[4]<=tmpKt)*(tmpInfer[5]>=tmpKt)
    # evl_cvrg[1] = (tmpInfer[4]<=tmpKt)*(tmpInfer[5]>=tmpKt)
    return [evl_bias_R,evl_bias_k,evl_cvrg,evl_cprb]



# single run
mean_GT = 5.2;
sd_GT   = 1.72;
MaxInfctPrd = int(mean_GT+3*sd_GT)+1; # maximum length of infectious period in day
Rt_seq = [1.1,1.3,1.5];
kt_seq = [0.2,0.5,2,5];
simDays_seq = [7,14,21];
tmpLEN = simDays_seq[2]
simuRun = 100;
initialCase = 10;
outPth = '/Users/macbjmu/Documents/research/NewIdeas/dynamic_Rt/dynaRt_code/simulation_code/simu_result_0916/'
outFile = outPth+'INDS0927_simuRun='+str(simuRun)+'_tmpLen='+str(tmpLEN)+'.csv';

# run simulation and write the results into a csv file
re = []
for tmpR in Rt_seq:
    for tmpK in kt_seq:
        re = [mltRun(mean_GT,sd_GT,MaxInfctPrd,initialCase,tmpR,tmpK,tmpLEN,simuRun)] 
        outcomes = pd.DataFrame(re)
        outcomes.to_csv(outFile,mode="a", header=False)
        



